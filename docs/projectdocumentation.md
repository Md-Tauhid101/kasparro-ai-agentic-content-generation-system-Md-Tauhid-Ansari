# Kasparro – Agentic Content Generation System Documentation

## 1. Problem Statement

D2C skincare brands need scalable, structured, and high-quality product content such as:

- FAQ Pages  
- Product Pages  
- Comparison Pages  

Manual creation does not scale. Traditional template-based systems fail because:

- Input product formats vary significantly  
- Ingredients, benefits, usage instructions, and pricing differ per product  
- Teams struggle to maintain consistent tone, structure, and SEO-friendly output  

The challenge is to design an **agentic content generation system** that:

- Accepts raw, messy product JSON  
- Normalizes it  
- Generates factual, well-structured, LLM-enhanced content  
- Outputs clean JSON compatible with SEO/CMS pipelines  

This system must be **modular, safe, deterministic, and extensible**.

---

## 2. Solution Overview

The solution is a **multi-agent pipeline** built using:

- **LangChain** → LLM chains (Parser, Questions, FAQ, Product Page, Comparison)  
- **LangGraph** → Workflow orchestration  
- **Pydantic Models** → Enforced structured output  
- **Hybrid deterministic + LLM logic**  

### Core Design Principles
- **LLM only where necessary** → All risky logic (benefits extraction, pricing logic) stays deterministic  
- **Strict JSON validation** → Prevent hallucinated structures  
- **Reusable templates** → Consistent formatting across products  
- **Extendable agents** → Easy to plug more pages (reviews, routines, bundle pages, etc.)  

---

## 3. System Scope & Assumptions

### Assumptions
- Input JSON contains:  
  `product_name`, `concentration`, `skin_type`, `key_ingredients`, `benefits`, `how_to_use`, `price`
- LLM may output malformed JSON → must be recovered and validated  
- Synthetic **Product B** is fully generated by LLM  
- No UI layer or front-end rendering is included  
- Output JSON files feed into downstream CMS/SEO tools  

### Out of Scope
- Product review generation  
- Image generation  
- Web scraping  
- Fine-tuned domain models  

---

## 4. Agentic System Architecture

### Multi-Agent Workflow (LangGraph)

```
                   Raw Input JSON
                          │
                          ▼
                     ParserAgent
                          │
         ┌────────────────┼────────────────┐
         ▼                ▼                ▼
  QuestionAgent   ProductPageAgent   ComparisonAgent
         │                │                │
         ▼                ▼                ▼
    FAQPageAgent      ProductPage     ComparisonPage
         │
         ▼
      FAQPage
```

---

## 5. Agents Breakdown

### **1. ParserAgent**
- Normalizes input → `ProductModel`
- Validates with Pydantic
- Fallback logic for missing fields

### **2. QuestionAgent**
- Generates 15 user questions  
- Uses strict `QuestionModel` schema  
- JSON-only output using LangChain LCEL pipeline

### **3. FAQPageAgent**
- Takes product + generated questions  
- Produces structured FAQ JSON  
- Uses PydanticOutputParser to guarantee schema compliance

### **4. ProductPageAgent**
- Builds structured product page  
- Contains blocks:
  - hero section  
  - benefits block  
  - usage block  
  - safety block  
  - ingredient block  
  - pricing block  
- All deterministic, no hallucinations

### **5. ComparisonAgent**
- Generates fictional Product B  
- Ensures:
  - different ingredients  
  - different benefits  
  - different concentration  
  - different use case  
  - different price  
- Creates:
  - Product A  
  - Product B  
  - Comparison list  
  - Summary

---

## 6. LangGraph DAG Design

### Node Sequence

```
parse → questions → faq → product → comparison → END
```

### State Object  
Shared across agents:

```python
PipelineState = {
  "raw_input": dict,
  "product": dict,
  "questions": list,
  "faq_page": dict,
  "product_page": dict,
  "comparison_page": dict
}
```

---

## 7. Pydantic Models

Models ensure every output follows strict structure:

- `ProductModel`
- `FAQItem` + `FAQPageModel`
- `ProductPageModel`
- `ComparisonItem` + `ComparisonPageModel`

Each output file **must** validate before saving.

---

## 8. Deterministic Blocks (tools.py)

Reusable functions create consistent output:

- `build_benefits_block()`
- `build_usage_block()`
- `build_ingredient_block()`
- `build_safety_block()`
- `build_price_block()`
- `build_comparison_block()`

These prevent hallucinations and ensure consistent formatting.

---

## 9. Output JSON Examples

### FAQ Output
```json
{
  "product_name": "GlowBoost Vitamin C Serum",
  "faqs": [
    {"question": "...", "answer": "..."},
    ...
  ]
}
```

### Product Page Output
```json
{
  "product_name": "GlowBoost Vitamin C Serum",
  "sections": [...]
}
```

### Comparison Output
```json
{
  "product_a": {...},
  "product_b": {...},
  "comparisons": [...],
  "summary": "..."
}
```

---

## 10. Why This System Works

- **LLM hallucinations minimized** with strict JSON schemas  
- **LangGraph ensures deterministic execution order**  
- **Reusable blocks guarantee consistent formatting**  
- **Agents are modular → easy to extend**  
- **Outputs are machine-ready JSON → ideal for SEO & CMS**  

---

## 11. Future Improvements

- Add embedding retrieval for factual claims  
- Add review generation agent  
- Add product routine generator  
- Implement caching for large product catalogs  
- Build FastAPI endpoints for real-time generation  

---

